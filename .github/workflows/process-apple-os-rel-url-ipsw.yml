name: Process Apple OS Release via Direct IPSW URL

on:
  workflow_dispatch:
    inputs:
      os_type:
        description: 'Operating System (e.g., iOS, iPadOS, macOS, visionOS)'
        required: true
        type: choice
        options:
          - iOS
          - iPadOS
          - macOS
          - visionOS
          - tvOS
      device_identifier:
        description: 'Device Identifier (e.g., iPhone18,1)'
        required: true
        type: string
      release_type:
        description: 'Type of release (beta or release)'
        required: true
        type: choice
        options: [beta, release]
        default: beta
      release_version:
        description: 'Version (e.g., 26.0). Used for the version tag.'
        required: true
        type: string
      release_build:
        description: 'Build ID (e.g., 23B82).'
        required: true
        type: string
      ipsw_url:
        description: 'Direct URL to the .ipsw file'
        required: true
        type: string
      checkout_branch:
        description: 'The base branch (for checkout, not PR since PR is handled by the other workflow).'
        required: false
        type: string
        default: 'main'
      exclude_info_plist:
        description: 'Exclude all files named "Info.plist" from processing.'
        required: true
        type: boolean
        default: true

jobs:
  process-ipsw:
    runs-on: macos-latest
    
    steps:
      - name: 1. Log Inputs to Job Summary for ${{ inputs.device_identifier }} on ${{ inputs.release_version }} (${{ inputs.release_build }})
        run: |
          echo "### ðŸš€ Workflow: 2. Process Apple URL IPSW" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Input | Value |" >> $GITHUB_STEP_SUMMARY
          echo "| :--- | :--- |" >> $GITHUB_STEP_SUMMARY
          echo "| **IPSW URL** | \`${{ inputs.ipsw_url }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **OS Type** | \`${{ inputs.os_type }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Release Type** | \`${{ inputs.release_type }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Release Version** | \`${{ inputs.release_version }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Release Build** | \`${{ inputs.release_build }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Device** | \`${{ inputs.device_identifier }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Checkout Branch** | \`${{ inputs.checkout_branch }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Exclude Info.plist** | \`${{ inputs.exclude_info_plist }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Run ID** | \`${{ github.run_id }}\` |" >> $GITHUB_STEP_SUMMARY

      - name: 2. Check out repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.checkout_branch }}

      - name: 3. Install Tools (ipsw and build aeota)
        run: |
          echo "Installing blacktop/ipsw..."
          brew install blacktop/tap/ipsw
          
          echo "Cloning and building dhinakg/aeota..."
          git clone https://github.com/dhinakg/aeota.git
          cd aeota
          
          echo "Setting up Python venv..."
          python3 -m venv .env
          source .env/bin/activate
          
          echo "Installing Python requirements..."
          pip3 install -r requirements.txt
          
          echo "Building aeota binaries..."
          make
          
          deactivate
          echo "aeota tools built in ./aeota/"
          ls -l ./

      - name: 4. Set up Python (for main script)
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: 5. Create output directories
        run: |
          mkdir -p ./ipsw_files
          mkdir -p ./ipsw_files/out

      - name: 6. Normalize device identifier
        id: normalize-key
        run: |
          NORMALIZED_ID=$(echo "${{ inputs.device_identifier }}" | tr ',' '_')
          echo "Normalized device ID: $NORMALIZED_ID"
          echo "id=${NORMALIZED_ID}" >> $GITHUB_OUTPUT

      - name: 7. Download IPSW from URL
        run: |
          echo "Downloading full IPSW from ${{ inputs.ipsw_url }}"
          DOWNLOAD_PATH="./ipsw_files/downloaded.ipsw"
          
          curl -L -o "${DOWNLOAD_PATH}" "${{ inputs.ipsw_url }}"
          
          if [[ ! -f "$DOWNLOAD_PATH" ]]; then
            echo "::error::Failed to download IPSW file from URL."
            exit 1
          fi
          
          echo "IPSW_FILE=${DOWNLOAD_PATH}" >> $GITHUB_ENV
          echo "Using IPSW: $DOWNLOAD_PATH"

      - name: 8. Extract and Decrypt Filesystem DMG
        run: |
          echo "Extracting filesystem DMG (encrypted)..."
          ipsw ex --dmg fs "${{ env.IPSW_FILE }}" -o ./ipsw_files/out
          
          FS_DMG_AEA=$(find ./ipsw_files/out -name "*dmg.aea" | head -n 1)
          if [[ -z "$FS_DMG_AEA" ]]; then
            echo "::error::Failed to find extracted *dmg.aea file."
            exit 1
          fi
          echo "Found encrypted DMG: $FS_DMG_AEA"

          echo "Unwrapping decryption key using get_key.py..."
          source ./aeota/.env/bin/activate
          DECRYPTION_KEY=$(python3 ./aeota/get_key.py "${FS_DMG_AEA}")
          echo "| **Decryption Key** | \`${DECRYPTION_KEY}\` |" >> $GITHUB_STEP_SUMMARY
          deactivate
          
          if [[ -z "$DECRYPTION_KEY" ]]; then
            echo "::error::Failed to get decryption key from get_key.py."
            exit 1
          fi
          echo "Successfully unwrapped key."

          echo "Decrypting DMG using 'aastuff_standalone'..."
          
          DECRYPT_PARENT_DIR="./ipsw_files/decrypted"
          mkdir -p $DECRYPT_PARENT_DIR
          
          AEA_BASENAME=$(basename "${FS_DMG_AEA}")
          DMG_FILENAME="${AEA_BASENAME%.aea}"
          DECRYPTED_DMG_PATH="${DECRYPT_PARENT_DIR}/${DMG_FILENAME}"

          echo "Encrypted file: ${FS_DMG_AEA}"
          echo "Expected output file: ${DECRYPTED_DMG_PATH}"
          
          ./aeota/aastuff_standalone -i "${FS_DMG_AEA}" -o "${DECRYPTED_DMG_PATH}" -d -k "${DECRYPTION_KEY}"
          
          echo "--- Listing contents of ${DECRYPT_PARENT_DIR} ---"
          ls -l $DECRYPT_PARENT_DIR
          echo "--- End of directory listing ---"
          
          if [[ ! -f "$DECRYPTED_DMG_PATH" ]]; then
            echo "::error::Failed to find decrypted .dmg file at ${DECRYPTED_DMG_PATH}."
            echo "Aastuff command finished, but the expected file was not found."
            exit 1
          fi

          echo "DECRYPTED_DMG=${DECRYPTED_DMG_PATH}" >> $GITHUB_ENV
          echo "Decrypted DMG at: $DECRYPTED_DMG_PATH"

      - name: 9. Mount Decrypted DMG
        run: |
          echo "Mounting DMG..."
          hdiutil attach "${{ env.DECRYPTED_DMG }}" -mountpoint ./mounted_dmg
          echo "MOUNT_PATH=./mounted_dmg" >> $GITHUB_ENV
          echo "DMG mounted at: ${{ env.MOUNT_PATH }}"
          ls -l ${{ env.MOUNT_PATH }}

      - name: 10. Clean and create output directory
        run: |
          echo "Cleaning and ensuring target directory exists: ${{ inputs.release_type }}"
          rm -rf "./${{ inputs.release_type }}"
          mkdir -p "./${{ inputs.release_type }}"

      - name: 11. Run Python Analyzer Script and Log Stats
        run: |
          REPO_SAVE_PATH="${{ inputs.release_type }}/${{ inputs.os_type }}"
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Python Processing Stats" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Folder | Duration | Files Found | Files Processed | Errors | Avg. Time (s) |" >> $GITHUB_STEP_SUMMARY
          echo "| :--- | :--- | :--- | :--- | :--- | :--- |" >> $GITHUB_STEP_SUMMARY

          run_and_log() {
            FOLDER_NAME=$1
            MOUNT_PATH=$2
            REPO_PATH=$3
            
            echo "--- Processing $FOLDER_NAME ---"
            
            START_TIME=$(date +%s)
            
            JSON_OUTPUT=$(python py.py "$MOUNT_PATH" "$REPO_PATH" "${{ inputs.exclude_info_plist }}")
            
            END_TIME=$(date +%s)
            DURATION_S=$((END_TIME - START_TIME))
            DURATION_FORMATTED=$(printf "%02d:%02d" $((DURATION_S/60)) $((DURATION_S%60)))

            if ! echo "$JSON_OUTPUT" | jq empty; then
              echo "::error::Failed to process $FOLDER_NAME. Output was not valid JSON."
              echo "Raw output: $JSON_OUTPUT"
              echo "| **$FOLDER_NAME** | $DURATION_FORMATTED | *Failed* | *Failed* | *Failed* | *Failed* |" >> $GITHUB_STEP_SUMMARY
              return
            fi

            FILES_FOUND=$(echo "$JSON_OUTPUT" | jq .files_found)
            FILES_PROCESSED=$(echo "$JSON_OUTPUT" | jq .valid_files_processed)
            ERROR_COUNT=$(echo "$JSON_OUTPUT" | jq .error_count)
            AVG_TIME=$(echo "$JSON_OUTPUT" | jq .avg_time_s | xargs printf "%.3f")

            echo "Finished $FOLDER_NAME processing (Duration: $DURATION_FORMATTED)"
            echo "| **$FOLDER_NAME** | $DURATION_FORMATTED | $FILES_FOUND | $FILES_PROCESSED | $ERROR_COUNT | $AVG_TIME |" >> $GITHUB_STEP_SUMMARY
            
            if [[ "$ERROR_COUNT" -gt 0 ]]; then
              echo "::warning::Encountered $ERROR_COUNT errors processing $FOLDER_NAME. See logs above for details."
            fi
          }

          if [[ "${{ inputs.os_type }}" == "macOS" ]]; then
            echo "macOS detected. Processing /System folder only..."
            run_and_log "System" "${{ env.MOUNT_PATH }}/System" "${REPO_SAVE_PATH}/System"
          else
            echo "${{ inputs.os_type }} detected. Processing standard root folders..."
            run_and_log "Applications" "${{ env.MOUNT_PATH }}/Applications" "${REPO_SAVE_PATH}/Applications"
            run_and_log "Library" "${{ env.MOUNT_PATH }}/Library" "${REPO_SAVE_PATH}/Library"
            run_and_log "private" "${{ env.MOUNT_PATH }}/private" "${REPO_SAVE_PATH}/private"
            run_and_log "System" "${{ env.MOUNT_PATH }}/System" "${REPO_SAVE_PATH}/System"
          fi
          
          echo "Waiting for worker processes to fully terminate..."
          sleep 5

      - name: 12. Sanitize File Paths
        run: |
          TARGET_DIR="./${{ inputs.release_type }}"
          echo "Searching for and renaming files/directories with colons in $TARGET_DIR..."
          find $TARGET_DIR -depth -name "*:*" -exec bash -c '
            dir=$(dirname "$0")
            base=$(basename "$0")
            new_base=$(echo "$base" | tr ":" "_")
            if [[ "$base" != "$new_base" ]]; then
              echo "Renaming $0 to $dir/$new_base"
              mv "$0" "$dir/$new_base"
            fi
          ' {} \;
          echo "Sanitization complete."

      - name: 13. Unmount DMG
        if: always()
        run: |
          echo "Attempting to unmount DMG: ./mounted_dmg"
          
          sync
          sleep 2
          
          if hdiutil detach ./mounted_dmg 2>/dev/null; then
            echo "DMG unmounted successfully"
          else
            echo "Normal detach failed, trying force detach..."
            hdiutil detach ./mounted_dmg -force || {
              echo "::warning::Force detach also failed, trying with diskutil..."
              MOUNT_POINT=$(diskutil info ./mounted_dmg | grep "Device Node" | awk '{print $3}')
              diskutil unmount force "$MOUNT_POINT" || echo "::warning::Could not unmount DMG, but continuing anyway"
            }
          fi

      - name: 14. Upload Analysis Artifact
        uses: actions/upload-artifact@v4
        with:
          name: analysis-${{ inputs.release_type }}-${{ inputs.os_type }}-${{ inputs.release_build }}-${{ inputs.device_identifier }}
          path: ./${{ inputs.release_type }}/${{ inputs.os_type }}
          retention-days: 90