name: 1. Process Apple Beta IPSW

on:
  workflow_dispatch:
    inputs:
      os_type:
        description: 'Operating System (e.g., iOS, iPadOS, visionOS)'
        required: true
        type: choice
        options:
          - iOS
          - iPadOS
          - visionOS
          - tvOS
          - macOS
      beta_version:
        description: 'Version (e.g., 26.0). Used for the version tag.'
        required: true
        type: string
      beta_build:
        description: 'Build ID (e.g., 23B5073a). Used for downloading.'
        required: true
        type: string
      device_identifier:
        description: 'Device Identifier (e.g., iPhone18,1)'
        required: true
        type: string
      checkout_branch:
        description: 'The base branch (for checkout, not PR since PR is handled by the other workflow).'
        required: false
        type: string
        default: 'main'

jobs:
  process-ipsw:
    runs-on: macos-latest
    
    steps:
      - name: 1. Check out repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.commit_branch }}

      - name: 2. Install blacktop/ipsw
        run: brew install blacktop/tap/ipsw

      - name: 3. Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: 4. Create output directories
        run: |
          # Create the directory for the download
          mkdir -p ./ipsw_files
          # Create the directory for the extracted files
          mkdir -p ./ipsw_files/out

      - name: 5. Download IPSW
        run: |
          echo "Downloading full IPSW for ${{ inputs.os_type }} build ${{ inputs.beta_build }} for device ${{ inputs.device_identifier }}"
          
          # Use the new os_type input
          ipsw dl appledb --os "${{ inputs.os_type }}" \
            --build "${{ inputs.beta_build }}" \
            --device "${{ inputs.device_identifier }}" \
            --output ./ipsw_files
          
          DOWNLOADED_FILE=$(find ./ipsw_files -name "*.ipsw" | head -n 1)
          if [[ -z "$DOWNLOADED_FILE" ]]; then
            echo "::error::Failed to download IPSW file."
            exit 1
          fi
          echo "IPSW_FILE=${DOWNLOADED_FILE}" >> $GITHUB_ENV
          echo "Downloaded: $DOWNLOADED_FILE"

      - name: 6. Extract and Decrypt Filesystem DMG
        run: |
          echo "Extracting filesystem DMG (encrypted)..."
          # Step A: Extract the .dmg.aea file using 'fs'
          ipsw ex --dmg fs "${{ env.IPSW_FILE }}" -o ./ipsw_files/out
          
          FS_DMG_AEA=$(find ./ipsw_files/out -name "*dmg.aea" | head -n 1)
          if [[ -z "$FS_DMG_AEA" ]]; then
            echo "::error::Failed to find extracted *dmg.aea file."
            exit 1
          fi
          echo "Found encrypted DMG: $FS_DMG_AEA"

          echo "Extracting decryption key (.pem)..."
          # Step B: Extract the .pem file
          ipsw ex --fcs-key "${{ env.IPSW_FILE }}" -o ./ipsw_files/out
          
          AEA_KEY=$(find ./ipsw_files/out -name "*aea.pem" | head -n 1)
          if [[ -z "$AEA_KEY" ]]; then
            echo "::error::Failed to find extracted *aea.pem key."
            exit 1
          fi
          echo "Found key: $AEA_KEY"

          echo "Decrypting DMG..."
          # Step C: Decrypt using the key with 'ipsw fw aea'
          ipsw fw aea --pem "${AEA_KEY}" "${FS_DMG_AEA}" -o ./ipsw_files/out
          
          DECRYPTED_DMG=$(find ./ipsw_files/out -name "*.dmg" | head -n 1)
          if [[ -z "$DECRYPTED_DMG" ]]; then
            echo "::error::Failed to find decrypted .dmg file."
            exit 1
          fi
          echo "DECRYPTED_DMG=${DECRYPTED_DMG}" >> $GITHUB_ENV
          echo "Decrypted DMG at: $DECRYPTED_DMG"

      - name: 7. Mount Decrypted DMG
        run: |
          echo "Mounting DMG..."
          hdiutil attach "${{ env.DECRYPTED_DMG }}" -mountpoint ./mounted_dmg
          echo "MOUNT_PATH=./mounted_dmg" >> $GITHUB_ENV
          echo "DMG mounted at: ${{ env.MOUNT_PATH }}"
          ls -l ${{ env.MOUNT_PATH }}

      - name: 8. Clean old beta directory
        run: |
          echo "Ensuring the 'beta' root directory exists..."
          mkdir -p beta

      - name: 9. Run Python Analyzer Script
        run: |
          # This is the new, dynamic path based on the OS
          REPO_SAVE_PATH="beta/${{ inputs.os_type }}"

          echo "Running Python script for Applications... (Output: ${REPO_SAVE_PATH}/Applications)"
          python py.py "${{ env.MOUNT_PATH }}/Applications" "${REPO_SAVE_PATH}/Applications"
          
          echo "Running Python script for Library... (Output: ${REPO_SAVE_PATH}/Library)"
          python py.py "${{ env.MOUNT_PATH }}/Library" "${REPO_SAVE_PATH}/Library"
          
          echo "Running Python script for private... (Output: ${REPO_SAVE_PATH}/private)"
          python py.py "${{ env.MOUNT_PATH }}/private" "${REPO_SAVE_PATH}/private"
          
          echo "Running Python script for System... (Output: ${REPO_SAVE_PATH}/System)"
          python py.py "${{ env.MOUNT_PATH }}/System" "${REPO_SAVE_PATH}/System"

      - name: 10. Unmount DMG
        if: always() # Always run this step, even if the script fails
        run: |
          echo "Unmounting DMG..."
          hdiutil detach ./mounted_dmg -force

      - name: 11. Upload Analysis Artifact
        uses: actions/upload-artifact@v4
        with:
          # Create a unique name for the artifact
          name: analysis-${{ inputs.os_type }}-${{ inputs.beta_build }}
          # Upload the entire 'beta' directory that your script generated
          path: ./beta/
          # Set retention to a few days
          retention-days: 5