name: 1. Process Apple OS Release IPSW

on:
  workflow_dispatch:
    inputs:
      os_type:
        description: 'Operating System (e.g., iOS, iPadOS, macOS, visionOS)'
        required: true
        type: choice
        options:
          - iOS
          - iPadOS
          - macOS
          - visionOS
          # - watchOS
          # - tvOS
      device_identifier:
        description: 'Device Identifier (e.g., iPhone18,1)'
        required: true
        type: string
      release_type:
        description: 'Type of release (beta or release)'
        required: true
        type: choice
        options: [beta, release]
        default: beta
      release_version:
        description: 'Version (e.g., 26.0). Used for the version tag.'
        required: true
        type: string
      release_build:
        description: 'Build ID (e.g., 23B82). Used for downloading.'
        required: true
        type: string
      checkout_branch:
        description: 'The base branch (for checkout, not PR since PR is handled by the other workflow).'
        required: false
        type: string
        default: 'main'
      exclude_info_plist:
        description: 'Exclude all files named "Info.plist" from processing.'
        required: true
        type: boolean
        default: true

jobs:
  process-ipsw:
    runs-on: macos-latest
    
    steps:
      - name: 1. Log Inputs to Job Summary
        run: |
          echo "### ðŸš€ Workflow: 1. Process Apple Release IPSW" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Input | Value |" >> $GITHUB_STEP_SUMMARY
          echo "| :--- | :--- |" >> $GITHUB_STEP_SUMMARY
          echo "| **OS Type** | \`${{ inputs.os_type }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Release Type** | \`${{ inputs.release_type }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Release Version** | \`${{ inputs.release_version }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Release Build** | \`${{ inputs.release_build }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Device** | \`${{ inputs.device_identifier }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Checkout Branch** | \`${{ inputs.checkout_branch }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Exclude Info.plist** | \`${{ inputs.exclude_info_plist }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Run ID** | \`${{ github.run_id }}\` |" >> $GITHUB_STEP_SUMMARY

      - name: 2. Check out repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.checkout_branch }}

      - name: 3. Get brew prefix and latest ipsw version
        id: brew-info
        run: |
          echo "brew_prefix=$(brew --prefix)" >> $GITHUB_OUTPUT
          
          IPSW_LATEST_TAG=$(curl -s "https://api.github.com/repos/blacktop/ipsw/releases/latest" | jq -r .tag_name)
          
          if [[ -z "$IPSW_LATEST_TAG" || "$IPSW_LATEST_TAG" == "null" ]]; then
            echo "::warning::Could not fetch latest ipsw tag. Using 'latest' as fallback."
            IPSW_LATEST_TAG="latest"
          fi
          
          echo "Latest ipsw tag: $IPSW_LATEST_TAG"
          echo "ipsw_version=${IPSW_LATEST_TAG}" >> $GITHUB_OUTPUT

      - name: 4. Cache Homebrew Installation
        uses: actions/cache@v4
        with:
          # Cache the entire Homebrew installation directory
          path: ${{ steps.brew-info.outputs.brew_prefix }}
          key: ${{ runner.os }}-brew-ipsw-${{ steps.brew-info.outputs.ipsw_version }}
          restore-keys: |
            ${{ runner.os }}-brew-ipsw-v3.1.634

      - name: 5. Install blacktop/ipsw
        run: brew install blacktop/tap/ipsw

      - name: 6. Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: 7. Create output directories
        run: |
          mkdir -p ./ipsw_files
          mkdir -p ./ipsw_files/out

      - name: 8. Normalize device identifier
        id: normalize-key
        run: |
          NORMALIZED_ID=$(echo "${{ inputs.device_identifier }}" | tr ',' '_')
          echo "Normalized device ID: $NORMALIZED_ID"
          echo "id=${NORMALIZED_ID}" >> $GITHUB_OUTPUT

      - name: 9. Download IPSW
        run: |
          echo "Downloading full IPSW for ${{ inputs.os_type }} build ${{ inputs.release_build }} for device ${{ inputs.device_identifier }}"
          
          ipsw dl appledb --os "${{ inputs.os_type }}" \
            --build "${{ inputs.release_build }}" \
            --device "${{ inputs.device_identifier }}" \
            --output ./ipsw_files
          
          DOWNLOADED_FILE=$(find ./ipsw_files -name "*.ipsw" | head -n 1)
          if [[ -z "$DOWNLOADED_FILE" ]]; then
            echo "::error::Failed to find IPSW file (from download)."
            exit 1
          fi
          
          echo "IPSW_FILE=${DOWNLOADED_FILE}" >> $GITHUB_ENV
          echo "Using IPSW: $DOWNLOADED_FILE"

      - name: 10. Extract and Decrypt Filesystem DMG
        run: |
          echo "Extracting filesystem DMG (encrypted)..."
          ipsw ex --dmg fs "${{ env.IPSW_FILE }}" -o ./ipsw_files/out
          
          FS_DMG_AEA=$(find ./ipsw_files/out -name "*dmg.aea" | head -n 1)
          if [[ -z "$FS_DMG_AEA" ]]; then
            echo "::error::Failed to find extracted *dmg.aea file."
            exit 1
          fi
          echo "Found encrypted DMG: $FS_DMG_AEA"

          echo "Extracting decryption key (.pem)..."
          ipsw ex --fcs-key "${{ env.IPSW_FILE }}" -o ./ipsw_files/out
          
          AEA_KEY=$(find ./ipsw_files/out -name "*aea.pem" | head -n 1)
          if [[ -z "$AEA_KEY" ]]; then
            echo "::error::Failed to find extracted *aea.pem key."
            exit 1
          fi
          echo "Found key: $AEA_KEY"

          echo "Decrypting DMG..."
          ipsw fw aea --pem "${AEA_KEY}" "${FS_DMG_AEA}" -o ./ipsw_files/out
          
          DECRYPTED_DMG=$(find ./ipsw_files/out -name "*.dmg" | head -n 1)
          if [[ -z "$DECRYPTED_DMG" ]]; then
            echo "::error::Failed to find decrypted .dmg file."
            exit 1
          fi
          echo "DECRYPTED_DMG=${DECRYPTED_DMG}" >> $GITHUB_ENV
          echo "Decrypted DMG at: $DECRYPTED_DMG"

      - name: 11. Mount Decrypted DMG
        run: |
          echo "Mounting DMG..."
          hdiutil attach "${{ env.DECRYPTED_DMG }}" -mountpoint ./mounted_dmg
          echo "MOUNT_PATH=./mounted_dmg" >> $GITHUB_ENV
          echo "DMG mounted at: ${{ env.MOUNT_PATH }}"
          ls -l ${{ env.MOUNT_PATH }}

      - name: 12. Clean and create output directory
        run: |
          echo "Cleaning and ensuring target directory exists: ${{ inputs.release_type }}"
          rm -rf "./${{ inputs.release_type }}"
          mkdir -p "./${{ inputs.release_type }}"

      - name: 13. Run Python Analyzer Script and Log Stats
        run: |
          REPO_SAVE_PATH="${{ inputs.release_type }}/${{ inputs.os_type }}"
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Python Processing Stats" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Folder | Duration | Files Found | Files Processed | Errors | Avg. Time (s) |" >> $GITHUB_STEP_SUMMARY
          echo "| :--- | :--- | :--- | :--- | :--- | :--- |" >> $GITHUB_STEP_SUMMARY

          run_and_log() {
            FOLDER_NAME=$1
            MOUNT_PATH=$2
            REPO_PATH=$3
            
            echo "--- Processing $FOLDER_NAME ---"
            
            START_TIME=$(date +%s)
            
            JSON_OUTPUT=$(python py.py "$MOUNT_PATH" "$REPO_PATH" "${{ inputs.exclude_info_plist }}")
            
            END_TIME=$(date +%s)
            DURATION_S=$((END_TIME - START_TIME))
            DURATION_FORMATTED=$(printf "%02d:%02d" $((DURATION_S/60)) $((DURATION_S%60)))

            if ! echo "$JSON_OUTPUT" | jq empty; then
              echo "::error::Failed to process $FOLDER_NAME. Output was not valid JSON."
              echo "Raw output: $JSON_OUTPUT"
              echo "| **$FOLDER_NAME** | $DURATION_FORMATTED | *Failed* | *Failed* | *Failed* | *Failed* |" >> $GITHUB_STEP_SUMMARY
              return
            fi

            FILES_FOUND=$(echo "$JSON_OUTPUT" | jq .files_found)
            FILES_PROCESSED=$(echo "$JSON_OUTPUT" | jq .valid_files_processed)
            ERROR_COUNT=$(echo "$JSON_OUTPUT" | jq .error_count)
            AVG_TIME=$(echo "$JSON_OUTPUT" | jq .avg_time_s | xargs printf "%.3f")

            echo "Finished $FOLDER_NAME processing (Duration: $DURATION_FORMATTED)"
            echo "| **$FOLDER_NAME** | $DURATION_FORMATTED | $FILES_FOUND | $FILES_PROCESSED | $ERROR_COUNT | $AVG_TIME |" >> $GITHUB_STEP_SUMMARY
            
            if [[ "$ERROR_COUNT" -gt 0 ]]; then
              echo "::warning::Encountered $ERROR_COUNT errors processing $FOLDER_NAME. See logs above for details."
            fi
          }

          if [[ "${{ inputs.os_type }}" == "macOS" ]]; then
            echo "macOS detected. Processing /System folder only..."
            run_and_log "System" "${{ env.MOUNT_PATH }}/System" "${REPO_SAVE_PATH}/System"
          else
            echo "${{ inputs.os_type }} detected. Processing standard root folders..."
            run_and_log "Applications" "${{ env.MOUNT_PATH }}/Applications" "${REPO_SAVE_PATH}/Applications"
            run_and_log "Library" "${{ env.MOUNT_PATH }}/Library" "${REPO_SAVE_PATH}/Library"
            run_and_log "private" "${{ env.MOUNT_PATH }}/private" "${REPO_SAVE_PATH}/private"
            run_and_log "System" "${{ env.MOUNT_PATH }}/System" "${REPO_SAVE_PATH}/System"
          fi

      - name: 14. Sanitize File Paths
        run: |
          TARGET_DIR="./${{ inputs.release_type }}"
          echo "Searching for and renaming files/directories with colons in $TARGET_DIR..."
          find $TARGET_DIR -depth -name "*:*" -exec bash -c '
            dir=$(dirname "$0")
            base=$(basename "$0")
            new_base=$(echo "$base" | tr ":" "_")
            if [[ "$base" != "$new_base" ]]; then
              echo "Renaming $0 to $dir/$new_base"
              mv "$0" "$dir/$new_base"
            fi
          ' {} \;
          echo "Sanitization complete."

      - name: 15. Unmount DMG
        if: always()
        run: |
          echo "Unmounting DMG..."
          hdiutil detach ./mounted_dmg -force

      - name: 16. Upload Analysis Artifact
        uses: actions/upload-artifact@v4
        with:
          name: analysis-${{ inputs.release_type }}-${{ inputs.os_type }}-${{ inputs.release_build }}-${{ inputs.device_identifier }}
          path: ./${{ inputs.release_type }}/${{ inputs.os_type }}
          retention-days: 90