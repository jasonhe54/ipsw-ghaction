name: Process Apple Beta IPSW

on:
  workflow_dispatch:
    inputs:
      os_type:
        description: 'Operating System (e.g., iOS, iPadOS, visionOS)'
        required: true
        type: choice
        options:
          - iOS
          - iPadOS
          - visionOS
          - tvOS
          - macOS
      beta_version:
        description: 'Version (e.g., 26.0). Used for the version tag.'
        required: true
        type: string
      beta_build:
        description: 'Build ID (e.g., 23B5073a). Used for downloading.'
        required: true
        type: string
      device_identifier:
        description: 'Device Identifier (e.g., iPhone18,1)'
        required: true
        type: string
      commit_branch:
        description: 'The base branch to create the Pull Request against.'
        required: false
        type: string
        default: 'main'

jobs:
  process-ipsw:
    runs-on: macos-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: 1. Check out repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.commit_branch }}

      - name: 2. Install blacktop/ipsw
        run: brew install blacktop/tap/ipsw

      - name: 3. Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: 4. Create output directories
        run: |
          mkdir -p ./ipsw_files
          mkdir -p ./ipsw_files/out
          
          # This is the new local copy directory
          mkdir -p ./local_pristine_copy

      - name: 5. Download IPSW
        run: |
          echo "Downloading full IPSW for ${{ inputs.os_type }} build ${{ inputs.beta_build }} for device ${{ inputs.device_identifier }}"
          
          ipsw dl appledb --os "${{ inputs.os_type }}" \
            --build "${{ inputs.beta_build }}" \
            --device "${{ inputs.device_identifier }}" \
            --output ./ipsw_files
          
          DOWNLOADED_FILE=$(find ./ipsw_files -name "*.ipsw" | head -n 1)
          if [[ -z "$DOWNLOADED_FILE" ]]; then
            echo "::error::Failed to download IPSW file."
            exit 1
          fi
          echo "IPSW_FILE=${DOWNLOADED_FILE}" >> $GITHUB_ENV
          echo "Downloaded: $DOWNLOADED_FILE"

      - name: 6. Extract and Decrypt Filesystem DMG
        run: |
          echo "Extracting filesystem DMG (encrypted)..."
          ipsw ex --dmg fs "${{ env.IPSW_FILE }}" -o ./ipsw_files/out
          FS_DMG_AEA=$(find ./ipsw_files/out -name "*dmg.aea" | head -n 1)
          if [[ -z "$FS_DMG_AEA" ]]; then echo "::error::Failed to find extracted *dmg.aea file."; exit 1; fi
          echo "Found encrypted DMG: $FS_DMG_AEA"
          echo "Extracting decryption key (.pem)..."
          ipsw ex --fcs-key "${{ env.IPSW_FILE }}" -o ./ipsw_files/out
          AEA_KEY=$(find ./ipsw_files/out -name "*aea.pem" | head -n 1)
          if [[ -z "$AEA_KEY" ]]; then echo "::error::Failed to find extracted *aea.pem key."; exit 1; fi
          echo "Found key: $AEA_KEY"
          echo "Decrypting DMG..."
          ipsw fw aea --pem "${AEA_KEY}" "${FS_DMG_AEA}" -o ./ipsw_files/out
          DECRYPTED_DMG=$(find ./ipsw_files/out -name "*.dmg" | head -n 1)
          if [[ -z "$DECRYPTED_DMG" ]]; then echo "::error::Failed to find decrypted .dmg file."; exit 1; fi
          echo "DECRYPTED_DMG=${DECRYPTED_DMG}" >> $GITHUB_ENV
          echo "Decrypted DMG at: $DECRYPTED_DMG"

      - name: 7. Mount Decrypted DMG
        run: |
          echo "Mounting DMG..."
          hdiutil attach "${{ env.DECRYPTED_DMG }}" -mountpoint ./mounted_dmg
          echo "MOUNT_PATH=./mounted_dmg" >> $GITHUB_ENV
          echo "DMG mounted at: ${{ env.MOUNT_PATH }}"
          ls -l ${{ env.MOUNT_PATH }}

      # --- NEW STEP ---
      - name: 8. Copy & Dereference DMG Contents
        run: |
          echo "Copying and dereferencing symlinks from DMG mount..."
          
          # The -L flag follows all symlinks, copying the
          # actual file they point to. This replicates
          # your manual copy process and fixes broken links.
          
          echo "Copying Applications..."
          cp -rL ./mounted_dmg/Applications ./local_pristine_copy/Applications
          
          echo "Copying Library..."
          cp -rL ./mounted_dmg/Library ./local_pristine_copy/Library
          
          echo "Copying private..."
          cp -rL ./mounted_dmg/private ./local_pristine_copy/private
          
          echo "Copying System..."
          cp -rL ./mounted_dmg/System ./local_pristine_copy/System
          
          echo "Copy complete."

      - name: 9. Clean 'beta' directory
        run: |
          echo "Ensuring the 'beta' root directory exists..."
          mkdir -p beta

      # --- MODIFIED STEP ---
      - name: 10. Run Python Analyzer Script
        run: |
          # This is the OS-specific path for the *final repo output*
          REPO_SAVE_PATH="beta/${{ inputs.os_type }}"

          # These paths now point to the 'local_pristine_copy'
          # This is the new *source* for the python script
          LOCAL_SOURCE_PATH="./local_pristine_copy"

          echo "Running Python script for Applications... (Output: ${REPO_SAVE_PATH}/Applications)"
          python py.py "${LOCAL_SOURCE_PATH}/Applications" "${REPO_SAVE_PATH}/Applications"
          
          echo "Running Python script for Library... (Output: ${REPO_SAVE_PATH}/Library)"
          python py.py "${LOCAL_SOURCE_PATH}/Library" "${REPO_SAVE_PATH}/Library"
          
          echo "Running Python script for private... (Output: ${REPO_SAVE_PATH}/private)"
          python py.py "${LOCAL_SOURCE_PATH}/private" "${REPO_SAVE_PATH}/private"
          
          echo "Running Python script for System... (Output: ${REPO_SAVE_PATH}/System)"
          python py.py "${LOCAL_SOURCE_PATH}/System" "${REPO_SAVE_PATH}/System"

      # --- MODIFIED STEP ---
      - name: 11. Unmount DMG and Clean Up
        if: always() # Always run this step
        run: |
          echo "Unmounting DMG..."
          hdiutil detach ./mounted_dmg -force
          
          echo "Cleaning up local pristine copy..."
          rm -rf ./local_pristine_copy
          
          echo "Cleaning up downloaded ipsw files..."
          rm -rf ./ipsw_files

      - name: 12. Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: 13. Commit and Create PR
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          
          OS_TYPE_LOWER=$(echo "${{ inputs.os_type }}" | tr '[:upper:]' '[:lower:]')
          VERSION_TAG="${OS_TYPE_LOWER}-${{ inputs.beta_version }}-${{ inputs.beta_build }}"
          CLEAN_VERSION_TAG=$(echo "${VERSION_TAG}" | sed 's/[^a-zA-Z0-9-]/_/g')
          TIMESTAMP=$(date +'%Y%m%d-%H%M%S')
          NEW_BRANCH="auto-analysis/${CLEAN_VERSION_TAG}-${TIMESTAMP}"
          
          git checkout -B "${NEW_BRANCH}"
          
          # This 'git add' command is still correct
          git add beta/
          
          if git diff --cached --quiet; then
            echo "No changes detected in 'beta' directory. Exiting."
            exit 0
          fi
          
          echo "Committing changes..."
          COMMIT_MSG="Analyze: ${{ inputs.os_type }} ${{ inputs.beta_version }} (${{ inputs.beta_build }})
          
          Device: ${{ inputs.device_identifier }}
          Processed folders: Applications, Library, private, System"
          
          git commit -m "$COMMIT_MSG"
          
          echo "Pushing branch ${NEW_BRANCH}..."
          git push --set-upstream origin "${NEW_BRANCH}"
          
          echo "Creating Pull Request..."
          PR_TITLE="Analysis: ${{ inputs.os_type }} ${{ inputs.beta_version }} (${{ inputs.beta_build }})"
          PR_BODY="Automated analysis of \`${{ inputs.os_type }}\` \`${{ inputs.beta_version }}\` (Build \`${{ inputs.beta_build }}\`).
          
          **Device:** \`${{ inputs.device_identifier }}\`
          **Processed DMG Folders:** \`Applications\`, \`Library\`, \`private\`, \`System\`
          **Output Repo Path:** \`/beta/${{ inputs.os_type }}\`"
          
          gh pr create \
            --base "${{ inputs.commit_branch }}" \
            --head "${NEW_BRANCH}" \
            --title "${PR_TITLE}" \
            --body "${PR_BODY}"